{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/head.jpg","path":"img/head.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1512822386845},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1512822386846},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1512822386846},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1512822386846},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1512822386848},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1512822386847},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1512822386848},{"_id":"themes/yilia/_config.yml","hash":"2c1f362582418f9fab48c8fbd1f88016f598ccb4","modified":1512837019825},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1512822386869},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1512822386906},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1512822386818},{"_id":"themes/yilia/.git/config","hash":"6c556d74461b3f33fe18d1726369cfa04377bed1","modified":1512822386828},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1512822338780},{"_id":"themes/yilia/.git/index","hash":"7357e257591d86949fc55c6c2e888910fabf7998","modified":1512825885530},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1512822386812},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1512822386849},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1512822386850},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1512822386850},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1512822386850},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1512822386851},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1512822386851},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1512822386852},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1512822386866},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1512822386866},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1512822386867},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1512822386866},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1512822386867},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1512822386868},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1512822386868},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1512822386903},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1512822386905},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1512822386869},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1512822386893},{"_id":"source/_posts/64位windows的Dos中取消了edit命令.md","hash":"243300ba6a2f203654e52e343e275548f9ad77a0","modified":1512826513555},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题.md","hash":"f98472a6be6de56e0dcf84341b444b2974441c82","modified":1512833725048},{"_id":"source/_posts/MySQL-驱动包在6-0版本后出现的坑.md","hash":"24cc2f5b880824eb556af5138f14d83c2919983b","modified":1533279495996},{"_id":"source/_posts/MySQL中的时间字段的几种数据类型比较.md","hash":"7c3cffc0bbfa84620ed33a5b022ad17458ddc964","modified":1534008663785},{"_id":"source/_posts/PHP链式操作.md","hash":"09b81312d59254f3ac8bd938143a499782556d02","modified":1540170542212},{"_id":"source/_posts/mergesort.md","hash":"30c9199a83c82cdafec83f4baa1f74e4fb3d5678","modified":1537798515872},{"_id":"source/_posts/quicksort.md","hash":"13dd51a78234355c59ecd27123a944bde3e0a41a","modified":1537799384818},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512822386864},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1512822386904},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1512822386905},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1512822338781},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1512822338781},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1512822338782},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1512822338782},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1512822338788},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1512822338783},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1512822338788},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1512822338788},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1512822338789},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1512822338789},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1512822338790},{"_id":"themes/yilia/.git/logs/HEAD","hash":"7abc3d7d69b5b0bb861b24dfea624664746e0ce9","modified":1512822386824},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"9af7354e076c1b231476a027c207c18d242a7a2f","modified":1512828658188},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1512822386853},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1512822386853},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7086c88a0391876db6b5c0e4641e5141150ff90e","modified":1512831159916},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1512822386854},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1512822386854},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1512822386855},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"54cd6ce6d1518d18dcb248daf930e486b1c28a49","modified":1512828998169},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1512822386856},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1512822386856},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1512822386857},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1512822386857},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1512822386857},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1512822386858},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1512822386865},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1512822386865},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1512822386894},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1512822386895},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1512822386896},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1512822386896},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1512822386897},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1512822386901},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1512822386901},{"_id":"themes/yilia/source/img/head.jpg","hash":"7d01365e8cb05e3c6763baa4c7b73b5324703f9a","modified":1512825808352},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1512822386902},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1512822386902},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1512822386870},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1512822386870},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1512822386870},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1512822386870},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1512822386871},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1512822386871},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1512822386872},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1512822386872},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1512822386872},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1512822386876},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1512822386879},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1512822386879},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1512822386879},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1512822386880},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1512822386881},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1512822386881},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1512822386882},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1512822386882},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1512822386882},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1512822386883},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1512822386883},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1512822386883},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1512822386884},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1512822386884},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1512822386884},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1512822386885},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1512822386885},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1512822386887},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1512822386886},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1512822386887},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1512822386887},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1512822386888},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1512822386888},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1512822386890},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1512822386890},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1512822386891},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1512822386891},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1512822386892},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1512822386892},{"_id":"source/_posts/64位windows的Dos中取消了edit命令/edit-notFound.png","hash":"44ec767f46bd2c11772905914331e90b063253c5","modified":1512824985893},{"_id":"source/_posts/64位windows的Dos中取消了edit命令/canNotRun.png","hash":"074eecd6f64849ae594e00c4035a357e8faba3d9","modified":1512825413374},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/code3.png","hash":"9fea7234982ede3422c5fbfe26ff685797a8bbf6","modified":1512827506413},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/code1.png","hash":"27e8c3367754bc60dd5905cfe8529c9da8ee8c61","modified":1512827320061},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/code2.png","hash":"3b58724e91371415344fb28a1e1fe56199f4243f","modified":1512827333529},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/description.png","hash":"b6449087e6783536c067eefaf6779e94465b9a61","modified":1512827573669},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1512822386864},{"_id":"themes/yilia/.git/objects/pack/pack-fac5d73365e7ed3fbebe7e5bb013d8e2fde035c8.idx","hash":"9e4c0b8bd8e21c5b315f7ddfaea85c5222618f77","modified":1512822386618},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1512822386824},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1512822386858},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1512822386859},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1512822386859},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1512822386860},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1512822386859},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1512822386860},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1512822386862},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1512822386862},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"3c412661566bdad15d2fa238bc1d830b0f8b73b6","modified":1512833506923},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1512822386863},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1512822386873},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1512822386874},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1512822386874},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1512822386875},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1512822386875},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1512822386877},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1512822386877},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1512822386878},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1512822386878},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1512822386880},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1512822386880},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1512822386881},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"7abc3d7d69b5b0bb861b24dfea624664746e0ce9","modified":1512822386825},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1512822386817},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"7abc3d7d69b5b0bb861b24dfea624664746e0ce9","modified":1512822386817},{"_id":"themes/yilia/.git/objects/pack/pack-fac5d73365e7ed3fbebe7e5bb013d8e2fde035c8.pack","hash":"d9184aae96c5e85a86bd65c945f4a3437c6ae45d","modified":1512822386698},{"_id":"public/content.json","hash":"45c81fdea90e06867134e038749c95cfc4af68e5","modified":1540172422809},{"_id":"public/2018/10/22/PHP链式操作/index.html","hash":"1b1e278d837f7c46c3b91d11e7e20892cfed0dcb","modified":1540172423033},{"_id":"public/2018/09/24/quicksort/index.html","hash":"4bdf324d01d2cad6b5a8ab6e67bf7acec2713c4d","modified":1540172423033},{"_id":"public/2018/09/24/mergesort/index.html","hash":"6ef609cf9441a6a468e1d0b03fecdd0158729d52","modified":1540172423033},{"_id":"public/2018/08/12/MySQL中的时间字段的几种数据类型比较/index.html","hash":"5cede27a0fd551fe69f5efd446733d289a23f5b4","modified":1540172423033},{"_id":"public/2018/08/03/MySQL-驱动包在6-0版本后出现的坑/index.html","hash":"c69a3e33758225dfc6ba3db1d62cfe9882c38d54","modified":1540172423034},{"_id":"public/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/index.html","hash":"618c1494145549fd493edeb9b3390b20d7c70150","modified":1540172423034},{"_id":"public/2017/12/09/64位windows的Dos中取消了edit命令/index.html","hash":"c085c3472718cc3de5a7d6fd1142103ab653e784","modified":1540172423034},{"_id":"public/categories/Windows相关/index.html","hash":"976b37dd146ba746650693ffc451729880a4e428","modified":1540172423034},{"_id":"public/categories/PHP/index.html","hash":"1b6169d6ba1a0f5b1879ecdd2409b84f005729a0","modified":1540172423034},{"_id":"public/categories/算法/index.html","hash":"8e8676d4ad7f6c27735c4facb0576ec1cf8889cb","modified":1540172423034},{"_id":"public/categories/JavaSE/index.html","hash":"2cac8193a48568202e4c1ff8d17a98f047418077","modified":1540172423034},{"_id":"public/tags/Java/index.html","hash":"0f6f9f91e46be23d09edfd2c56415e75f2041f24","modified":1540172423035},{"_id":"public/tags/JDBC/index.html","hash":"b52b2472fe589435b44326ec59cd540b4661c1cf","modified":1540172423035},{"_id":"public/tags/MySQL/index.html","hash":"1113ecf4e5e23fe00c0ab7d8c9759370c0adc767","modified":1540172423035},{"_id":"public/tags/JAR/index.html","hash":"f8d8e45db99df222c728db8f2281fdde4f7cf40e","modified":1540172423035},{"_id":"public/tags/Windows/index.html","hash":"29d01a1045917da983a3055b92eee7a2d60b8325","modified":1540172423035},{"_id":"public/tags/Dos/index.html","hash":"825616bb0aa0c8584a5082fb19f0843b576cf006","modified":1540172423035},{"_id":"public/tags/PHP/index.html","hash":"3e804bf1019bbd3803359c944abed1b4a4911885","modified":1540172423035},{"_id":"public/tags/算法/index.html","hash":"d7159fd6b4ad022146b942ddcc66c370ddada60d","modified":1540172423035},{"_id":"public/tags/排序/index.html","hash":"c3402110a134e6cde447408da6b43a41f2c6487b","modified":1540172423036},{"_id":"public/index.html","hash":"ff09f069ff04b787e4acf49a3eed6a25ac02be9a","modified":1540172423036},{"_id":"public/page/2/index.html","hash":"771953e151fa1d01907d4e1fe89c4d9bc66fcefe","modified":1540172423036},{"_id":"public/archives/index.html","hash":"af5c59eee858f39825e8f01cd6a4b858f6c44c1f","modified":1540172423036},{"_id":"public/archives/2017/index.html","hash":"152f40bfc34b0ffb89b285962c160d8103dcd755","modified":1540172423036},{"_id":"public/archives/2017/12/index.html","hash":"c8e120a5ad4213a0772743fdaac7ea43a585c2b0","modified":1540172423036},{"_id":"public/archives/2018/index.html","hash":"f78c1137705e8c678c7bcf93c07981688541252a","modified":1540172423036},{"_id":"public/archives/2018/08/index.html","hash":"51860ba9ac868b57f79f1662e2902b6de2a15ee3","modified":1540172423037},{"_id":"public/archives/2018/09/index.html","hash":"00924a921805fe2d984b17cf12eeed32c5e71776","modified":1540172423037},{"_id":"public/archives/2018/10/index.html","hash":"d0371facf85600cbe24da2c8272da84b4d52dd72","modified":1540172423037},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1540172423078},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1540172423078},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1540172423078},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1540172423078},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1540172423078},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1540172423078},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1540172423078},{"_id":"public/img/head.jpg","hash":"7d01365e8cb05e3c6763baa4c7b73b5324703f9a","modified":1540172423078},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1540172423078},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1540172423079},{"_id":"public/2017/12/09/64位windows的Dos中取消了edit命令/edit-notFound.png","hash":"44ec767f46bd2c11772905914331e90b063253c5","modified":1540172423079},{"_id":"public/2017/12/09/64位windows的Dos中取消了edit命令/canNotRun.png","hash":"074eecd6f64849ae594e00c4035a357e8faba3d9","modified":1540172423079},{"_id":"public/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code1.png","hash":"27e8c3367754bc60dd5905cfe8529c9da8ee8c61","modified":1540172423079},{"_id":"public/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code2.png","hash":"3b58724e91371415344fb28a1e1fe56199f4243f","modified":1540172423079},{"_id":"public/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code3.png","hash":"9fea7234982ede3422c5fbfe26ff685797a8bbf6","modified":1540172423079},{"_id":"public/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/description.png","hash":"b6449087e6783536c067eefaf6779e94465b9a61","modified":1540172423079},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1540172423091},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1540172423092},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1540172423092},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1540172423092}],"Category":[{"name":"Windows相关","_id":"cjnjmw6qq0005rwty7930g96t"},{"name":"PHP","_id":"cjnjmw6r2000arwtyl7i72k5v"},{"name":"算法","_id":"cjnjmw6r7000erwtyejj2eds7"},{"name":"JavaSE","_id":"cjnjmw6rh000lrwtyoxe6lelb"}],"Data":[],"Page":[],"Post":[{"title":"MySQL 驱动包在6.0版本后出现的坑","date":"2018-08-03T06:00:41.000Z","_content":"\n近段时间在复习JDBC时遇到了一些新的问题，写下此篇文章记录一下\n\n<!-- more -->\n\n## 加载驱动的类在包内位置变更\n\n按往常一样写好连接数据库的方法之后导入的包是：\n\n```java\nimport com.mysql.jdbc.Driver\n```\n\n运行之后报错\n\n> Loading class `com.mysql.jdbc.Driver`. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver`. The driver is automatically   registered via the SPI and manual loading of the driver class is generally unnecessary.\n\n 意思是说在`com.mysql.jdbc.Driver`下的类已经被弃用了，新的driver类在`com.mysql.cj.jdbc.Driver`下。\n\n 这是在6.0版本的驱动包后出现的，所以我们将路径改为新的路径即可。\n\n## 新版本驱动在访问数据库时无法识别时区\n\n报错信息为：\n\n> Error querying database.  Cause: java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.\n\n服务器的时区值 xxx 是无法试别或者代表了多个时区。\n\n用sql查看一下数据库时区\n\n```sql\nSELECT TIMEDIFF(NOW(), UTC_TIMESTAMP);\n```\n\n如果是中国标准时间，会输出08:00\n\n> +----------------------------------------------------+\n> | TIMEDIFF(NOW(), UTC_TIMESTAMP) |\n> +----------------------------------------------------+\n> | 08:00:00                                                |\n> +----------------------------------------------------+\n\n解决方案有两个第一个是修改JDBC连接数据库时的url值\n\n```\njdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC\n```\n\n添加一个`serverTimezone`的参数表明时区，UTC代表东八区。\n\n第二个方案是直接去修改数据库，输入\n\n```sql\nset global time_zone='+8:00';\n```\n\n​\n\n​","source":"_posts/MySQL-驱动包在6-0版本后出现的坑.md","raw":"---\ntitle: MySQL 驱动包在6.0版本后出现的坑\ndate: 2018-08-03 14:00:41\ntags: [Java,JDBC,MySQL,JAR]\n---\n\n近段时间在复习JDBC时遇到了一些新的问题，写下此篇文章记录一下\n\n<!-- more -->\n\n## 加载驱动的类在包内位置变更\n\n按往常一样写好连接数据库的方法之后导入的包是：\n\n```java\nimport com.mysql.jdbc.Driver\n```\n\n运行之后报错\n\n> Loading class `com.mysql.jdbc.Driver`. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver`. The driver is automatically   registered via the SPI and manual loading of the driver class is generally unnecessary.\n\n 意思是说在`com.mysql.jdbc.Driver`下的类已经被弃用了，新的driver类在`com.mysql.cj.jdbc.Driver`下。\n\n 这是在6.0版本的驱动包后出现的，所以我们将路径改为新的路径即可。\n\n## 新版本驱动在访问数据库时无法识别时区\n\n报错信息为：\n\n> Error querying database.  Cause: java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.\n\n服务器的时区值 xxx 是无法试别或者代表了多个时区。\n\n用sql查看一下数据库时区\n\n```sql\nSELECT TIMEDIFF(NOW(), UTC_TIMESTAMP);\n```\n\n如果是中国标准时间，会输出08:00\n\n> +----------------------------------------------------+\n> | TIMEDIFF(NOW(), UTC_TIMESTAMP) |\n> +----------------------------------------------------+\n> | 08:00:00                                                |\n> +----------------------------------------------------+\n\n解决方案有两个第一个是修改JDBC连接数据库时的url值\n\n```\njdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC\n```\n\n添加一个`serverTimezone`的参数表明时区，UTC代表东八区。\n\n第二个方案是直接去修改数据库，输入\n\n```sql\nset global time_zone='+8:00';\n```\n\n​\n\n​","slug":"MySQL-驱动包在6-0版本后出现的坑","published":1,"updated":"2018-08-03T06:58:15.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6qa0000rwtybmerkcr8","content":"<p>近段时间在复习JDBC时遇到了一些新的问题，写下此篇文章记录一下</p>\n<a id=\"more\"></a>\n<h2 id=\"加载驱动的类在包内位置变更\"><a href=\"#加载驱动的类在包内位置变更\" class=\"headerlink\" title=\"加载驱动的类在包内位置变更\"></a>加载驱动的类在包内位置变更</h2><p>按往常一样写好连接数据库的方法之后导入的包是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>\n<p>运行之后报错</p>\n<blockquote>\n<p>Loading class <code>com.mysql.jdbc.Driver</code>. This is deprecated. The new driver class is <code>com.mysql.cj.jdbc.Driver</code>. The driver is automatically   registered via the SPI and manual loading of the driver class is generally unnecessary.</p>\n</blockquote>\n<p> 意思是说在<code>com.mysql.jdbc.Driver</code>下的类已经被弃用了，新的driver类在<code>com.mysql.cj.jdbc.Driver</code>下。</p>\n<p> 这是在6.0版本的驱动包后出现的，所以我们将路径改为新的路径即可。</p>\n<h2 id=\"新版本驱动在访问数据库时无法识别时区\"><a href=\"#新版本驱动在访问数据库时无法识别时区\" class=\"headerlink\" title=\"新版本驱动在访问数据库时无法识别时区\"></a>新版本驱动在访问数据库时无法识别时区</h2><p>报错信息为：</p>\n<blockquote>\n<p>Error querying database.  Cause: java.sql.SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</p>\n</blockquote>\n<p>服务器的时区值 xxx 是无法试别或者代表了多个时区。</p>\n<p>用sql查看一下数据库时区</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">TIMEDIFF</span>(<span class=\"keyword\">NOW</span>(), <span class=\"keyword\">UTC_TIMESTAMP</span>);</span><br></pre></td></tr></table></figure>\n<p>如果是中国标准时间，会输出08:00</p>\n<blockquote>\n<p>+—————————————————-+<br>| TIMEDIFF(NOW(), UTC_TIMESTAMP) |<br>+—————————————————-+<br>| 08:00:00                                                |<br>+—————————————————-+</p>\n</blockquote>\n<p>解决方案有两个第一个是修改JDBC连接数据库时的url值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC</span><br></pre></td></tr></table></figure>\n<p>添加一个<code>serverTimezone</code>的参数表明时区，UTC代表东八区。</p>\n<p>第二个方案是直接去修改数据库，输入</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> <span class=\"keyword\">time_zone</span>=<span class=\"string\">'+8:00'</span>;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p>​</p>\n","site":{"data":{}},"excerpt":"<p>近段时间在复习JDBC时遇到了一些新的问题，写下此篇文章记录一下</p>","more":"<h2 id=\"加载驱动的类在包内位置变更\"><a href=\"#加载驱动的类在包内位置变更\" class=\"headerlink\" title=\"加载驱动的类在包内位置变更\"></a>加载驱动的类在包内位置变更</h2><p>按往常一样写好连接数据库的方法之后导入的包是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>\n<p>运行之后报错</p>\n<blockquote>\n<p>Loading class <code>com.mysql.jdbc.Driver</code>. This is deprecated. The new driver class is <code>com.mysql.cj.jdbc.Driver</code>. The driver is automatically   registered via the SPI and manual loading of the driver class is generally unnecessary.</p>\n</blockquote>\n<p> 意思是说在<code>com.mysql.jdbc.Driver</code>下的类已经被弃用了，新的driver类在<code>com.mysql.cj.jdbc.Driver</code>下。</p>\n<p> 这是在6.0版本的驱动包后出现的，所以我们将路径改为新的路径即可。</p>\n<h2 id=\"新版本驱动在访问数据库时无法识别时区\"><a href=\"#新版本驱动在访问数据库时无法识别时区\" class=\"headerlink\" title=\"新版本驱动在访问数据库时无法识别时区\"></a>新版本驱动在访问数据库时无法识别时区</h2><p>报错信息为：</p>\n<blockquote>\n<p>Error querying database.  Cause: java.sql.SQLException: The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</p>\n</blockquote>\n<p>服务器的时区值 xxx 是无法试别或者代表了多个时区。</p>\n<p>用sql查看一下数据库时区</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">TIMEDIFF</span>(<span class=\"keyword\">NOW</span>(), <span class=\"keyword\">UTC_TIMESTAMP</span>);</span><br></pre></td></tr></table></figure>\n<p>如果是中国标准时间，会输出08:00</p>\n<blockquote>\n<p>+—————————————————-+<br>| TIMEDIFF(NOW(), UTC_TIMESTAMP) |<br>+—————————————————-+<br>| 08:00:00                                                |<br>+—————————————————-+</p>\n</blockquote>\n<p>解决方案有两个第一个是修改JDBC连接数据库时的url值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC</span><br></pre></td></tr></table></figure>\n<p>添加一个<code>serverTimezone</code>的参数表明时区，UTC代表东八区。</p>\n<p>第二个方案是直接去修改数据库，输入</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> <span class=\"keyword\">time_zone</span>=<span class=\"string\">'+8:00'</span>;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n<p>​</p>"},{"title":"MySQL中的时间字段的几种数据类型比较","date":"2018-08-11T16:10:08.000Z","_content":"\n# 1.序言\n\n​\t最近在项目开发时，对于MySQL数据库中的有关时间的字段该选用何种类型，引发了一些争论。所以做了一些简单的研究，看了一些blog，和官方文档。最后做出一个自己的总结。\n\n<!-- more -->\n\n# 2.类型比较\n\n## INT\n\n​\tINT类型一般用于存储Unix时间戳。使用一个简单的 INT 列保存 Unix 时间是最普通的方法。使用 INT，你可以确保你要保存的数字可以快速、可靠地插入到表中。\n\n- 占用4个字节\n\n- 建立索引之后，查询速度快\n\n- 条件范围搜索可以使用使用between\n\n- 不能使用MySQL提供的时间函数\n\n\n\n\n  \t如果只是存储 Unix 时间戳（并且在它的合法日期范围内），而且不打算在它上面使用任何基于日期的查询，我觉得使用 INT 是可以的。它执行简单数值比较查询时非常快，因为只是在处理简单的数字。\n\n__结论：__适合需要进行大量时间范围查询的数据表\n\n\n\n## TIMESTAMP和DATETIME\n\n​\tDatetime 和 Timestamp 都保存日期和时间信息，同时，使用人类可读的日期形式，如 \"2018-01-01\"。\n\n> TIMESTAMP: A four-byte integer representing seconds UTC since the epoch ('1970-01-01 00:00:00' UTC)\n\n​\tTIMESTAMP：一个四字节的整数，从1970-01-01 00:00:00开始算起。\n\n​\tTimestamp 和 Datetime 的核心不同点主要在于 MySQL在内部如何表示这些信息：**两种都以二进制而非字符串形式存储**，但在表示日期/时间部分时 Timestamp （4 字节） 比 Datetime （5字节，从MySQL 5.6.4版本起，之前为8个字节） 少使用 1 字节。当保存毫秒部分时两种都使用额外的空间 （1到3 字节）。\n\n- 非分数部分的DATETIME编码（5.6.4版本之后）：\n\n  ```\n   1 bit  sign           (1= non-negative, 0= negative)\n  17 bits year*13+month  (year 0-9999, month 0-12)\n   5 bits day            (0-31)\n   5 bits hour           (0-23)\n   6 bits minute         (0-59)\n   6 bits second         (0-59)\n  ---------------------------\n  40 bits = 5 bytes\n  ```\n\n\n\nTimestamp 节省的 1 字节是有代价的：你只能存储从 '1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999' 之间的时间。而 Datetime 允许你存储从 '1000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999' 之间的任何时间。\n\n另一个重要的差别是MySQL使用**服务器的时区**转换Timestamp值到它的 UTC 等价值再保存。当获取值是它会再次进行时区转换，所以你得回了你“原始的”日期/时间值。Datetime 列不会被数据库改变。无论时区怎样配置，每次都会保存和获取到同样的值。\n\n在5.6版本之后，datetime开始可以使用current time作为默认值，所以不再有timestamp比datetime更适合作为需要随插入和更新来变更时间的类型的说法。\n\n\n\n__结论：__Datetime 是大多数场景下的最佳选择，理由是\n\n> 无需任何转换即是人类可读的。\n>\n> 不会因为时区变换产生问题。\n>\n> 只比TIMESTAMP多用 1 字节\n>\n> 支持更大的日期范围（从 1000 年到 9999 年）\n\n# 3.总结\n\n​\t没有完美的数据类型，只要最合适的数据类型。这么多类型同时存在一定是有其道理的，了解清楚了不同类型的差异，就能选择最合适的类型。\n\n\n\n参考：\n\n[1]: https://www.jb51.net/article/125715.htm 解析MySQL中存储时间日期类型的选择问题\n\n[2]: https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html Date and Time Data Type Representation\n\n[3]: https://www.jianshu.com/p/ec77b0631886 MySQL中你应该使用什么数据类型表示时间？\n\n","source":"_posts/MySQL中的时间字段的几种数据类型比较.md","raw":"---\ntitle: MySQL中的时间字段的几种数据类型比较\ndate: 2018-08-12 00:10:08\ntags: [MySQL]\n---\n\n# 1.序言\n\n​\t最近在项目开发时，对于MySQL数据库中的有关时间的字段该选用何种类型，引发了一些争论。所以做了一些简单的研究，看了一些blog，和官方文档。最后做出一个自己的总结。\n\n<!-- more -->\n\n# 2.类型比较\n\n## INT\n\n​\tINT类型一般用于存储Unix时间戳。使用一个简单的 INT 列保存 Unix 时间是最普通的方法。使用 INT，你可以确保你要保存的数字可以快速、可靠地插入到表中。\n\n- 占用4个字节\n\n- 建立索引之后，查询速度快\n\n- 条件范围搜索可以使用使用between\n\n- 不能使用MySQL提供的时间函数\n\n\n\n\n  \t如果只是存储 Unix 时间戳（并且在它的合法日期范围内），而且不打算在它上面使用任何基于日期的查询，我觉得使用 INT 是可以的。它执行简单数值比较查询时非常快，因为只是在处理简单的数字。\n\n__结论：__适合需要进行大量时间范围查询的数据表\n\n\n\n## TIMESTAMP和DATETIME\n\n​\tDatetime 和 Timestamp 都保存日期和时间信息，同时，使用人类可读的日期形式，如 \"2018-01-01\"。\n\n> TIMESTAMP: A four-byte integer representing seconds UTC since the epoch ('1970-01-01 00:00:00' UTC)\n\n​\tTIMESTAMP：一个四字节的整数，从1970-01-01 00:00:00开始算起。\n\n​\tTimestamp 和 Datetime 的核心不同点主要在于 MySQL在内部如何表示这些信息：**两种都以二进制而非字符串形式存储**，但在表示日期/时间部分时 Timestamp （4 字节） 比 Datetime （5字节，从MySQL 5.6.4版本起，之前为8个字节） 少使用 1 字节。当保存毫秒部分时两种都使用额外的空间 （1到3 字节）。\n\n- 非分数部分的DATETIME编码（5.6.4版本之后）：\n\n  ```\n   1 bit  sign           (1= non-negative, 0= negative)\n  17 bits year*13+month  (year 0-9999, month 0-12)\n   5 bits day            (0-31)\n   5 bits hour           (0-23)\n   6 bits minute         (0-59)\n   6 bits second         (0-59)\n  ---------------------------\n  40 bits = 5 bytes\n  ```\n\n\n\nTimestamp 节省的 1 字节是有代价的：你只能存储从 '1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999' 之间的时间。而 Datetime 允许你存储从 '1000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999' 之间的任何时间。\n\n另一个重要的差别是MySQL使用**服务器的时区**转换Timestamp值到它的 UTC 等价值再保存。当获取值是它会再次进行时区转换，所以你得回了你“原始的”日期/时间值。Datetime 列不会被数据库改变。无论时区怎样配置，每次都会保存和获取到同样的值。\n\n在5.6版本之后，datetime开始可以使用current time作为默认值，所以不再有timestamp比datetime更适合作为需要随插入和更新来变更时间的类型的说法。\n\n\n\n__结论：__Datetime 是大多数场景下的最佳选择，理由是\n\n> 无需任何转换即是人类可读的。\n>\n> 不会因为时区变换产生问题。\n>\n> 只比TIMESTAMP多用 1 字节\n>\n> 支持更大的日期范围（从 1000 年到 9999 年）\n\n# 3.总结\n\n​\t没有完美的数据类型，只要最合适的数据类型。这么多类型同时存在一定是有其道理的，了解清楚了不同类型的差异，就能选择最合适的类型。\n\n\n\n参考：\n\n[1]: https://www.jb51.net/article/125715.htm 解析MySQL中存储时间日期类型的选择问题\n\n[2]: https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html Date and Time Data Type Representation\n\n[3]: https://www.jianshu.com/p/ec77b0631886 MySQL中你应该使用什么数据类型表示时间？\n\n","slug":"MySQL中的时间字段的几种数据类型比较","published":1,"updated":"2018-08-11T17:31:03.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6qh0001rwty8nzksofd","content":"<h1 id=\"1-序言\"><a href=\"#1-序言\" class=\"headerlink\" title=\"1.序言\"></a>1.序言</h1><p>​    最近在项目开发时，对于MySQL数据库中的有关时间的字段该选用何种类型，引发了一些争论。所以做了一些简单的研究，看了一些blog，和官方文档。最后做出一个自己的总结。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-类型比较\"><a href=\"#2-类型比较\" class=\"headerlink\" title=\"2.类型比较\"></a>2.类型比较</h1><h2 id=\"INT\"><a href=\"#INT\" class=\"headerlink\" title=\"INT\"></a>INT</h2><p>​    INT类型一般用于存储Unix时间戳。使用一个简单的 INT 列保存 Unix 时间是最普通的方法。使用 INT，你可以确保你要保存的数字可以快速、可靠地插入到表中。</p>\n<ul>\n<li><p>占用4个字节</p>\n</li>\n<li><p>建立索引之后，查询速度快</p>\n</li>\n<li><p>条件范围搜索可以使用使用between</p>\n</li>\n<li><p>不能使用MySQL提供的时间函数</p>\n</li>\n</ul>\n<pre><code>如果只是存储 Unix 时间戳（并且在它的合法日期范围内），而且不打算在它上面使用任何基于日期的查询，我觉得使用 INT 是可以的。它执行简单数值比较查询时非常快，因为只是在处理简单的数字。\n</code></pre><p><strong>结论：</strong>适合需要进行大量时间范围查询的数据表</p>\n<h2 id=\"TIMESTAMP和DATETIME\"><a href=\"#TIMESTAMP和DATETIME\" class=\"headerlink\" title=\"TIMESTAMP和DATETIME\"></a>TIMESTAMP和DATETIME</h2><p>​    Datetime 和 Timestamp 都保存日期和时间信息，同时，使用人类可读的日期形式，如 “2018-01-01”。</p>\n<blockquote>\n<p>TIMESTAMP: A four-byte integer representing seconds UTC since the epoch (‘1970-01-01 00:00:00’ UTC)</p>\n</blockquote>\n<p>​    TIMESTAMP：一个四字节的整数，从1970-01-01 00:00:00开始算起。</p>\n<p>​    Timestamp 和 Datetime 的核心不同点主要在于 MySQL在内部如何表示这些信息：<strong>两种都以二进制而非字符串形式存储</strong>，但在表示日期/时间部分时 Timestamp （4 字节） 比 Datetime （5字节，从MySQL 5.6.4版本起，之前为8个字节） 少使用 1 字节。当保存毫秒部分时两种都使用额外的空间 （1到3 字节）。</p>\n<ul>\n<li><p>非分数部分的DATETIME编码（5.6.4版本之后）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 bit  sign           (1= non-negative, 0= negative)</span><br><span class=\"line\">17 bits year*13+month  (year 0-9999, month 0-12)</span><br><span class=\"line\"> 5 bits day            (0-31)</span><br><span class=\"line\"> 5 bits hour           (0-23)</span><br><span class=\"line\"> 6 bits minute         (0-59)</span><br><span class=\"line\"> 6 bits second         (0-59)</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">40 bits = 5 bytes</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Timestamp 节省的 1 字节是有代价的：你只能存储从 ‘1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’ 之间的时间。而 Datetime 允许你存储从 ‘1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’ 之间的任何时间。</p>\n<p>另一个重要的差别是MySQL使用<strong>服务器的时区</strong>转换Timestamp值到它的 UTC 等价值再保存。当获取值是它会再次进行时区转换，所以你得回了你“原始的”日期/时间值。Datetime 列不会被数据库改变。无论时区怎样配置，每次都会保存和获取到同样的值。</p>\n<p>在5.6版本之后，datetime开始可以使用current time作为默认值，所以不再有timestamp比datetime更适合作为需要随插入和更新来变更时间的类型的说法。</p>\n<p><strong>结论：</strong>Datetime 是大多数场景下的最佳选择，理由是</p>\n<blockquote>\n<p>无需任何转换即是人类可读的。</p>\n<p>不会因为时区变换产生问题。</p>\n<p>只比TIMESTAMP多用 1 字节</p>\n<p>支持更大的日期范围（从 1000 年到 9999 年）</p>\n</blockquote>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h1><p>​    没有完美的数据类型，只要最合适的数据类型。这么多类型同时存在一定是有其道理的，了解清楚了不同类型的差异，就能选择最合适的类型。</p>\n<p>参考：</p>\n<p>[1]: <a href=\"https://www.jb51.net/article/125715.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/125715.htm</a> 解析MySQL中存储时间日期类型的选择问题</p>\n<p>[2]: <a href=\"https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html</a> Date and Time Data Type Representation</p>\n<p>[3]: <a href=\"https://www.jianshu.com/p/ec77b0631886\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ec77b0631886</a> MySQL中你应该使用什么数据类型表示时间？</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-序言\"><a href=\"#1-序言\" class=\"headerlink\" title=\"1.序言\"></a>1.序言</h1><p>​    最近在项目开发时，对于MySQL数据库中的有关时间的字段该选用何种类型，引发了一些争论。所以做了一些简单的研究，看了一些blog，和官方文档。最后做出一个自己的总结。</p>","more":"<h1 id=\"2-类型比较\"><a href=\"#2-类型比较\" class=\"headerlink\" title=\"2.类型比较\"></a>2.类型比较</h1><h2 id=\"INT\"><a href=\"#INT\" class=\"headerlink\" title=\"INT\"></a>INT</h2><p>​    INT类型一般用于存储Unix时间戳。使用一个简单的 INT 列保存 Unix 时间是最普通的方法。使用 INT，你可以确保你要保存的数字可以快速、可靠地插入到表中。</p>\n<ul>\n<li><p>占用4个字节</p>\n</li>\n<li><p>建立索引之后，查询速度快</p>\n</li>\n<li><p>条件范围搜索可以使用使用between</p>\n</li>\n<li><p>不能使用MySQL提供的时间函数</p>\n</li>\n</ul>\n<pre><code>如果只是存储 Unix 时间戳（并且在它的合法日期范围内），而且不打算在它上面使用任何基于日期的查询，我觉得使用 INT 是可以的。它执行简单数值比较查询时非常快，因为只是在处理简单的数字。\n</code></pre><p><strong>结论：</strong>适合需要进行大量时间范围查询的数据表</p>\n<h2 id=\"TIMESTAMP和DATETIME\"><a href=\"#TIMESTAMP和DATETIME\" class=\"headerlink\" title=\"TIMESTAMP和DATETIME\"></a>TIMESTAMP和DATETIME</h2><p>​    Datetime 和 Timestamp 都保存日期和时间信息，同时，使用人类可读的日期形式，如 “2018-01-01”。</p>\n<blockquote>\n<p>TIMESTAMP: A four-byte integer representing seconds UTC since the epoch (‘1970-01-01 00:00:00’ UTC)</p>\n</blockquote>\n<p>​    TIMESTAMP：一个四字节的整数，从1970-01-01 00:00:00开始算起。</p>\n<p>​    Timestamp 和 Datetime 的核心不同点主要在于 MySQL在内部如何表示这些信息：<strong>两种都以二进制而非字符串形式存储</strong>，但在表示日期/时间部分时 Timestamp （4 字节） 比 Datetime （5字节，从MySQL 5.6.4版本起，之前为8个字节） 少使用 1 字节。当保存毫秒部分时两种都使用额外的空间 （1到3 字节）。</p>\n<ul>\n<li><p>非分数部分的DATETIME编码（5.6.4版本之后）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 1 bit  sign           (1= non-negative, 0= negative)</span><br><span class=\"line\">17 bits year*13+month  (year 0-9999, month 0-12)</span><br><span class=\"line\"> 5 bits day            (0-31)</span><br><span class=\"line\"> 5 bits hour           (0-23)</span><br><span class=\"line\"> 6 bits minute         (0-59)</span><br><span class=\"line\"> 6 bits second         (0-59)</span><br><span class=\"line\">---------------------------</span><br><span class=\"line\">40 bits = 5 bytes</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Timestamp 节省的 1 字节是有代价的：你只能存储从 ‘1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’ 之间的时间。而 Datetime 允许你存储从 ‘1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’ 之间的任何时间。</p>\n<p>另一个重要的差别是MySQL使用<strong>服务器的时区</strong>转换Timestamp值到它的 UTC 等价值再保存。当获取值是它会再次进行时区转换，所以你得回了你“原始的”日期/时间值。Datetime 列不会被数据库改变。无论时区怎样配置，每次都会保存和获取到同样的值。</p>\n<p>在5.6版本之后，datetime开始可以使用current time作为默认值，所以不再有timestamp比datetime更适合作为需要随插入和更新来变更时间的类型的说法。</p>\n<p><strong>结论：</strong>Datetime 是大多数场景下的最佳选择，理由是</p>\n<blockquote>\n<p>无需任何转换即是人类可读的。</p>\n<p>不会因为时区变换产生问题。</p>\n<p>只比TIMESTAMP多用 1 字节</p>\n<p>支持更大的日期范围（从 1000 年到 9999 年）</p>\n</blockquote>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h1><p>​    没有完美的数据类型，只要最合适的数据类型。这么多类型同时存在一定是有其道理的，了解清楚了不同类型的差异，就能选择最合适的类型。</p>\n<p>参考：</p>\n<p>[1]: <a href=\"https://www.jb51.net/article/125715.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/125715.htm</a> 解析MySQL中存储时间日期类型的选择问题</p>\n<p>[2]: <a href=\"https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html</a> Date and Time Data Type Representation</p>\n<p>[3]: <a href=\"https://www.jianshu.com/p/ec77b0631886\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ec77b0631886</a> MySQL中你应该使用什么数据类型表示时间？</p>"},{"title":"64位windows的Dos中取消了edit命令","date":"2017-12-09T13:01:26.000Z","_content":"\n前段时间在玩dos命令行的时候，用copy con创建了txt文件后想对其进行编辑，然后我又不想用记事本，所以去网上找命令行中对文本文件进行编辑的命令（纯属想装B），结果看到了edit命令。\n\n一敲，就出现了如下所示问题\n\n<!--more-->\n\n![](64位windows的Dos中取消了edit命令/edit-notFound.png)\n\n告诉我edit不是内部或外部命令，也不是可运行的程序。然后我就懵了，度娘骗我？\n\n然后我告诉了我的室友，结果他试了一下edit命令发现可以。我，？？？。然后我再上网查，百度百科中对edit命令做了如下解释：\n\nedit是DOS操作系统中的一个行编辑器程序，用于查看、编辑、创建计算机上的文本文件。该程序在Windows操作系统中也存在<font color = red>**（不含64位系统）**</font>。\n\nemmm，原因找到了，我的系统是64位的，所以不存在很正常。网上说可以把32位的edit.exe下载后放到C:\\Windows\\SysWOW64\\下，我试了一下，呵呵。\n\n![](64位windows的Dos中取消了edit命令/canNotRun.png)\n\n此答案来自某知道。我觉得自己不知道的东西或者没有试验过的就不要随便乱讲，误人子弟。\n\n后来找到一个echo命令，可以对文本内容进行覆盖或者追加，无法自由编辑。最后我还是老老实实的用了记事本。。。\n\n如果你的系统是32位的还没有办法使用edit命令的话，嗯，倒是可以用某知道的方法解决,去下载一下32位的edit.exe,然后放到c盘下的system32的文件夹里面。\n\n如果各位有更好的方法在dos下进行文本文件编辑可以留言告诉我！大家一起学习~","source":"_posts/64位windows的Dos中取消了edit命令.md","raw":"---\ntitle: 64位windows的Dos中取消了edit命令\ndate: 2017-12-09 21:01:26\ncategories: Windows相关\ntags: [Windows,Dos]\n---\n\n前段时间在玩dos命令行的时候，用copy con创建了txt文件后想对其进行编辑，然后我又不想用记事本，所以去网上找命令行中对文本文件进行编辑的命令（纯属想装B），结果看到了edit命令。\n\n一敲，就出现了如下所示问题\n\n<!--more-->\n\n![](64位windows的Dos中取消了edit命令/edit-notFound.png)\n\n告诉我edit不是内部或外部命令，也不是可运行的程序。然后我就懵了，度娘骗我？\n\n然后我告诉了我的室友，结果他试了一下edit命令发现可以。我，？？？。然后我再上网查，百度百科中对edit命令做了如下解释：\n\nedit是DOS操作系统中的一个行编辑器程序，用于查看、编辑、创建计算机上的文本文件。该程序在Windows操作系统中也存在<font color = red>**（不含64位系统）**</font>。\n\nemmm，原因找到了，我的系统是64位的，所以不存在很正常。网上说可以把32位的edit.exe下载后放到C:\\Windows\\SysWOW64\\下，我试了一下，呵呵。\n\n![](64位windows的Dos中取消了edit命令/canNotRun.png)\n\n此答案来自某知道。我觉得自己不知道的东西或者没有试验过的就不要随便乱讲，误人子弟。\n\n后来找到一个echo命令，可以对文本内容进行覆盖或者追加，无法自由编辑。最后我还是老老实实的用了记事本。。。\n\n如果你的系统是32位的还没有办法使用edit命令的话，嗯，倒是可以用某知道的方法解决,去下载一下32位的edit.exe,然后放到c盘下的system32的文件夹里面。\n\n如果各位有更好的方法在dos下进行文本文件编辑可以留言告诉我！大家一起学习~","slug":"64位windows的Dos中取消了edit命令","published":1,"updated":"2017-12-09T13:35:13.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6qm0003rwtyf04rxonn","content":"<p>前段时间在玩dos命令行的时候，用copy con创建了txt文件后想对其进行编辑，然后我又不想用记事本，所以去网上找命令行中对文本文件进行编辑的命令（纯属想装B），结果看到了edit命令。</p>\n<p>一敲，就出现了如下所示问题</p>\n<a id=\"more\"></a>\n<p><img src=\"/2017/12/09/64位windows的Dos中取消了edit命令/edit-notFound.png\" alt=\"\"></p>\n<p>告诉我edit不是内部或外部命令，也不是可运行的程序。然后我就懵了，度娘骗我？</p>\n<p>然后我告诉了我的室友，结果他试了一下edit命令发现可以。我，？？？。然后我再上网查，百度百科中对edit命令做了如下解释：</p>\n<p>edit是DOS操作系统中的一个行编辑器程序，用于查看、编辑、创建计算机上的文本文件。该程序在Windows操作系统中也存在<font color=\"red\"><strong>（不含64位系统）</strong></font>。</p>\n<p>emmm，原因找到了，我的系统是64位的，所以不存在很正常。网上说可以把32位的edit.exe下载后放到C:\\Windows\\SysWOW64\\下，我试了一下，呵呵。</p>\n<p><img src=\"/2017/12/09/64位windows的Dos中取消了edit命令/canNotRun.png\" alt=\"\"></p>\n<p>此答案来自某知道。我觉得自己不知道的东西或者没有试验过的就不要随便乱讲，误人子弟。</p>\n<p>后来找到一个echo命令，可以对文本内容进行覆盖或者追加，无法自由编辑。最后我还是老老实实的用了记事本。。。</p>\n<p>如果你的系统是32位的还没有办法使用edit命令的话，嗯，倒是可以用某知道的方法解决,去下载一下32位的edit.exe,然后放到c盘下的system32的文件夹里面。</p>\n<p>如果各位有更好的方法在dos下进行文本文件编辑可以留言告诉我！大家一起学习~</p>\n","site":{"data":{}},"excerpt":"<p>前段时间在玩dos命令行的时候，用copy con创建了txt文件后想对其进行编辑，然后我又不想用记事本，所以去网上找命令行中对文本文件进行编辑的命令（纯属想装B），结果看到了edit命令。</p>\n<p>一敲，就出现了如下所示问题</p>","more":"<p><img src=\"/2017/12/09/64位windows的Dos中取消了edit命令/edit-notFound.png\" alt=\"\"></p>\n<p>告诉我edit不是内部或外部命令，也不是可运行的程序。然后我就懵了，度娘骗我？</p>\n<p>然后我告诉了我的室友，结果他试了一下edit命令发现可以。我，？？？。然后我再上网查，百度百科中对edit命令做了如下解释：</p>\n<p>edit是DOS操作系统中的一个行编辑器程序，用于查看、编辑、创建计算机上的文本文件。该程序在Windows操作系统中也存在<font color=\"red\"><strong>（不含64位系统）</strong></font>。</p>\n<p>emmm，原因找到了，我的系统是64位的，所以不存在很正常。网上说可以把32位的edit.exe下载后放到C:\\Windows\\SysWOW64\\下，我试了一下，呵呵。</p>\n<p><img src=\"/2017/12/09/64位windows的Dos中取消了edit命令/canNotRun.png\" alt=\"\"></p>\n<p>此答案来自某知道。我觉得自己不知道的东西或者没有试验过的就不要随便乱讲，误人子弟。</p>\n<p>后来找到一个echo命令，可以对文本内容进行覆盖或者追加，无法自由编辑。最后我还是老老实实的用了记事本。。。</p>\n<p>如果你的系统是32位的还没有办法使用edit命令的话，嗯，倒是可以用某知道的方法解决,去下载一下32位的edit.exe,然后放到c盘下的system32的文件夹里面。</p>\n<p>如果各位有更好的方法在dos下进行文本文件编辑可以留言告诉我！大家一起学习~</p>"},{"title":"PHP链式操作","date":"2018-10-22T00:53:28.000Z","_content":"\n​        我们经常会在各种的PHP框架中看到链式操作，最常见的是在对数据库的操作中\n\n<!-- more -->\n\n```php\n$result = $this->table($table)\n    ->alias('fd')\n    ->join('user u', 'u.id = fd.user_id')\n    ->order($order)\n    ->paginate();\n```\n\n​        那么它是如何实现的呢？\n\n​        首先我们自己建一个database类\n\n```php\nclass Database\n{\n    function where($where)\n    {\n      \n    }\n\t\n    function order($order)\n    {\n      \n    }\n  \n    function limit($limit)\n    {\n      \n    }\n}\n```\n\n​        如果我们要查数据库的话，就得这么写\n\n```php\n$db = new Database();\n$db->where(\"id = 1\");\n$db->order(\"id desc\");\n$db->limit(10)\n```\n\n​        可以看到这样写特别麻烦，要分成多行，所以我们选择采用链式操作。\n\n​        将Database类进行修改\n\n```php\nclass Database\n{\n\tfunction where($where)\n    {\n        return $this;\n    }\n\t\n  \tfunction order($order)\n    {\n        return $this;\n    }\n  \n  \tfunction limit($limit)\n    {\n        return $this;\n    }\n}\n```\n\n​        每个方法返回都$this，就可以使用链式操作了。\n\n```php\n$db = new Database();\n$db->where(\"id = 1\")->order(\"id desc\")->limit(10);\n```\n\n","source":"_posts/PHP链式操作.md","raw":"---\ntitle: PHP链式操作\ndate: 2018-10-22 08:53:28\ncategories: PHP\ntags: [PHP]\n---\n\n​        我们经常会在各种的PHP框架中看到链式操作，最常见的是在对数据库的操作中\n\n<!-- more -->\n\n```php\n$result = $this->table($table)\n    ->alias('fd')\n    ->join('user u', 'u.id = fd.user_id')\n    ->order($order)\n    ->paginate();\n```\n\n​        那么它是如何实现的呢？\n\n​        首先我们自己建一个database类\n\n```php\nclass Database\n{\n    function where($where)\n    {\n      \n    }\n\t\n    function order($order)\n    {\n      \n    }\n  \n    function limit($limit)\n    {\n      \n    }\n}\n```\n\n​        如果我们要查数据库的话，就得这么写\n\n```php\n$db = new Database();\n$db->where(\"id = 1\");\n$db->order(\"id desc\");\n$db->limit(10)\n```\n\n​        可以看到这样写特别麻烦，要分成多行，所以我们选择采用链式操作。\n\n​        将Database类进行修改\n\n```php\nclass Database\n{\n\tfunction where($where)\n    {\n        return $this;\n    }\n\t\n  \tfunction order($order)\n    {\n        return $this;\n    }\n  \n  \tfunction limit($limit)\n    {\n        return $this;\n    }\n}\n```\n\n​        每个方法返回都$this，就可以使用链式操作了。\n\n```php\n$db = new Database();\n$db->where(\"id = 1\")->order(\"id desc\")->limit(10);\n```\n\n","slug":"PHP链式操作","published":1,"updated":"2018-10-22T01:09:02.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6qo0004rwtygkesrvly","content":"<p>​        我们经常会在各种的PHP框架中看到链式操作，最常见的是在对数据库的操作中</p>\n<a id=\"more\"></a>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$result = <span class=\"keyword\">$this</span>-&gt;table($table)</span><br><span class=\"line\">    -&gt;alias(<span class=\"string\">'fd'</span>)</span><br><span class=\"line\">    -&gt;join(<span class=\"string\">'user u'</span>, <span class=\"string\">'u.id = fd.user_id'</span>)</span><br><span class=\"line\">    -&gt;order($order)</span><br><span class=\"line\">    -&gt;paginate();</span><br></pre></td></tr></table></figure>\n<p>​        那么它是如何实现的呢？</p>\n<p>​        首先我们自己建一个database类</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Database</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">where</span><span class=\"params\">($where)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span><span class=\"params\">($order)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">limit</span><span class=\"params\">($limit)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​        如果我们要查数据库的话，就得这么写</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$db = <span class=\"keyword\">new</span> Database();</span><br><span class=\"line\">$db-&gt;where(<span class=\"string\">\"id = 1\"</span>);</span><br><span class=\"line\">$db-&gt;order(<span class=\"string\">\"id desc\"</span>);</span><br><span class=\"line\">$db-&gt;limit(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>​        可以看到这样写特别麻烦，要分成多行，所以我们选择采用链式操作。</p>\n<p>​        将Database类进行修改</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Database</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">where</span><span class=\"params\">($where)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span><span class=\"params\">($order)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">limit</span><span class=\"params\">($limit)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​        每个方法返回都$this，就可以使用链式操作了。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$db = <span class=\"keyword\">new</span> Database();</span><br><span class=\"line\">$db-&gt;where(<span class=\"string\">\"id = 1\"</span>)-&gt;order(<span class=\"string\">\"id desc\"</span>)-&gt;limit(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​        我们经常会在各种的PHP框架中看到链式操作，最常见的是在对数据库的操作中</p>","more":"<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$result = <span class=\"keyword\">$this</span>-&gt;table($table)</span><br><span class=\"line\">    -&gt;alias(<span class=\"string\">'fd'</span>)</span><br><span class=\"line\">    -&gt;join(<span class=\"string\">'user u'</span>, <span class=\"string\">'u.id = fd.user_id'</span>)</span><br><span class=\"line\">    -&gt;order($order)</span><br><span class=\"line\">    -&gt;paginate();</span><br></pre></td></tr></table></figure>\n<p>​        那么它是如何实现的呢？</p>\n<p>​        首先我们自己建一个database类</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Database</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">where</span><span class=\"params\">($where)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span><span class=\"params\">($order)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">limit</span><span class=\"params\">($limit)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​        如果我们要查数据库的话，就得这么写</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$db = <span class=\"keyword\">new</span> Database();</span><br><span class=\"line\">$db-&gt;where(<span class=\"string\">\"id = 1\"</span>);</span><br><span class=\"line\">$db-&gt;order(<span class=\"string\">\"id desc\"</span>);</span><br><span class=\"line\">$db-&gt;limit(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>​        可以看到这样写特别麻烦，要分成多行，所以我们选择采用链式操作。</p>\n<p>​        将Database类进行修改</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Database</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">where</span><span class=\"params\">($where)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">order</span><span class=\"params\">($order)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">limit</span><span class=\"params\">($limit)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​        每个方法返回都$this，就可以使用链式操作了。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$db = <span class=\"keyword\">new</span> Database();</span><br><span class=\"line\">$db-&gt;where(<span class=\"string\">\"id = 1\"</span>)-&gt;order(<span class=\"string\">\"id desc\"</span>)-&gt;limit(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>"},{"title":"归并排序","date":"2018-09-24T13:55:02.000Z","description":"归并排序的Go语言实现版本","_content":"\n​        归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n<!--more-->\n\n- Go代码（从小到大排序）:\n\n  ```go\n  func mergeSort(arr []int, l int, r int)  {\n      // 递归到最后的返回条件\n      if l >= r {    // 当片段的最左索引超过最右索引\n          return\n      }\n\n      mid := (l + r) / 2\n      mergeSort(arr, l, mid)\n      mergeSort(arr, mid+1, r)\n      // 简单优化，若左片段的最大值已经小于右片段的最小值，表明此时已经为有序\n      if arr[mid] > arr[mid+1]{\n          merge(arr, l, mid, r)\n      }\n  }\n\n  func merge(arr []int, l int, mid int, r int)  {\n      var aux = make([]int, r-l+1)\n      // 创建一个临时数组，存放当前待排序的片段\n      for i := l; i <= r; i++ {\n          aux[i-l] = arr[i]\n      }\n\n      i := l\n      j := mid + 1\n      // 合并两个片段\n      for k := l; k <= r; k++ {\n          if i > mid {\n              arr[k] = aux[j-l]\n              j++\n          } else if j > r {\n              arr[k] = aux[i-l]\n              i++\n          } else if aux[i-l] < aux[j-l] {\n              arr[k] = aux[i-l]\n              i++\n          } else if aux[i-l] > aux[j-l] {\n              arr[k] = aux[j-l]\n              j++\n          }\n      }\n  }\n  ```\n\n  ​","source":"_posts/mergesort.md","raw":"---\ntitle: 归并排序\ndate: 2018-09-24 21:55:02\ncategories: 算法\ntags: [算法, 排序]\ndescription: 归并排序的Go语言实现版本\n---\n\n​        归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n<!--more-->\n\n- Go代码（从小到大排序）:\n\n  ```go\n  func mergeSort(arr []int, l int, r int)  {\n      // 递归到最后的返回条件\n      if l >= r {    // 当片段的最左索引超过最右索引\n          return\n      }\n\n      mid := (l + r) / 2\n      mergeSort(arr, l, mid)\n      mergeSort(arr, mid+1, r)\n      // 简单优化，若左片段的最大值已经小于右片段的最小值，表明此时已经为有序\n      if arr[mid] > arr[mid+1]{\n          merge(arr, l, mid, r)\n      }\n  }\n\n  func merge(arr []int, l int, mid int, r int)  {\n      var aux = make([]int, r-l+1)\n      // 创建一个临时数组，存放当前待排序的片段\n      for i := l; i <= r; i++ {\n          aux[i-l] = arr[i]\n      }\n\n      i := l\n      j := mid + 1\n      // 合并两个片段\n      for k := l; k <= r; k++ {\n          if i > mid {\n              arr[k] = aux[j-l]\n              j++\n          } else if j > r {\n              arr[k] = aux[i-l]\n              i++\n          } else if aux[i-l] < aux[j-l] {\n              arr[k] = aux[i-l]\n              i++\n          } else if aux[i-l] > aux[j-l] {\n              arr[k] = aux[j-l]\n              j++\n          }\n      }\n  }\n  ```\n\n  ​","slug":"mergesort","published":1,"updated":"2018-09-24T14:15:15.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6qs0006rwtyfq2iw9np","content":"<p>​        归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>Go代码（从小到大排序）:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mergeSort</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 递归到最后的返回条件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r &#123;    <span class=\"comment\">// 当片段的最左索引超过最右索引</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">    mergeSort(arr, l, mid)</span><br><span class=\"line\">    mergeSort(arr, mid+<span class=\"number\">1</span>, r)</span><br><span class=\"line\">    <span class=\"comment\">// 简单优化，若左片段的最大值已经小于右片段的最小值，表明此时已经为有序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> arr[mid] &gt; arr[mid+<span class=\"number\">1</span>]&#123;</span><br><span class=\"line\">        merge(arr, l, mid, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, mid <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> aux = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, r-l+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个临时数组，存放当前待排序的片段</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := l; i &lt;= r; i++ &#123;</span><br><span class=\"line\">        aux[i-l] = arr[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i := l</span><br><span class=\"line\">    j := mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 合并两个片段</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k := l; k &lt;= r; k++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; mid &#123;</span><br><span class=\"line\">            arr[k] = aux[j-l]</span><br><span class=\"line\">            j++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> j &gt; r &#123;</span><br><span class=\"line\">            arr[k] = aux[i-l]</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> aux[i-l] &lt; aux[j-l] &#123;</span><br><span class=\"line\">            arr[k] = aux[i-l]</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> aux[i-l] &gt; aux[j-l] &#123;</span><br><span class=\"line\">            arr[k] = aux[j-l]</span><br><span class=\"line\">            j++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>​        归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>","more":"<ul>\n<li><p>Go代码（从小到大排序）:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mergeSort</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 递归到最后的返回条件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r &#123;    <span class=\"comment\">// 当片段的最左索引超过最右索引</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">    mergeSort(arr, l, mid)</span><br><span class=\"line\">    mergeSort(arr, mid+<span class=\"number\">1</span>, r)</span><br><span class=\"line\">    <span class=\"comment\">// 简单优化，若左片段的最大值已经小于右片段的最小值，表明此时已经为有序</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> arr[mid] &gt; arr[mid+<span class=\"number\">1</span>]&#123;</span><br><span class=\"line\">        merge(arr, l, mid, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, mid <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> aux = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, r-l+<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个临时数组，存放当前待排序的片段</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := l; i &lt;= r; i++ &#123;</span><br><span class=\"line\">        aux[i-l] = arr[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i := l</span><br><span class=\"line\">    j := mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 合并两个片段</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k := l; k &lt;= r; k++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; mid &#123;</span><br><span class=\"line\">            arr[k] = aux[j-l]</span><br><span class=\"line\">            j++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> j &gt; r &#123;</span><br><span class=\"line\">            arr[k] = aux[i-l]</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> aux[i-l] &lt; aux[j-l] &#123;</span><br><span class=\"line\">            arr[k] = aux[i-l]</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> aux[i-l] &gt; aux[j-l] &#123;</span><br><span class=\"line\">            arr[k] = aux[j-l]</span><br><span class=\"line\">            j++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>"},{"title":"快速排序","date":"2018-09-24T14:17:02.000Z","description":"快速排序的Go语言实现","_content":"\n​        快速排序（Quicksort）是对冒泡排序的一种改进。\n\n​        快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n<!--more-->\n\n- Go代码（从小到大）\n\n  ```go\n  // 交换两个数的位置\n  func swap(i *int, j *int) {\n      temp := *i\n      *i = *j\n      *j = temp\n  }\n\n  // 将片段分为大于v和小于v的两部分，并将两部分的分界索引值返回\n  func Partition(arr []int, l int, r int) int {\n      v := arr[l]\n\n      j := l\n      for i := l + 1; i <= r; i++ {\n          if arr[i] < v {\n              swap(&arr[j+1], &arr[i])\n              j++\n          }\n      }\n      swap(&arr[l], &arr[j])\n      return j\n  }\n\n  // 递归\n  func Sort(arr []int, l int, r int)  {\n      if l >= r {\n          return\n      }\n\n      p := Partition(arr, l, r)\n      Sort(arr, l, p)\n      Sort(arr, p+1, r)\n  }\n  ```\n\n  ​","source":"_posts/quicksort.md","raw":"---\ntitle: 快速排序\ndate: 2018-09-24 22:17:02\ncategories: 算法\ntags: [算法, 排序]\ndescription: 快速排序的Go语言实现\n---\n\n​        快速排序（Quicksort）是对冒泡排序的一种改进。\n\n​        快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n<!--more-->\n\n- Go代码（从小到大）\n\n  ```go\n  // 交换两个数的位置\n  func swap(i *int, j *int) {\n      temp := *i\n      *i = *j\n      *j = temp\n  }\n\n  // 将片段分为大于v和小于v的两部分，并将两部分的分界索引值返回\n  func Partition(arr []int, l int, r int) int {\n      v := arr[l]\n\n      j := l\n      for i := l + 1; i <= r; i++ {\n          if arr[i] < v {\n              swap(&arr[j+1], &arr[i])\n              j++\n          }\n      }\n      swap(&arr[l], &arr[j])\n      return j\n  }\n\n  // 递归\n  func Sort(arr []int, l int, r int)  {\n      if l >= r {\n          return\n      }\n\n      p := Partition(arr, l, r)\n      Sort(arr, l, p)\n      Sort(arr, p+1, r)\n  }\n  ```\n\n  ​","slug":"quicksort","published":1,"updated":"2018-09-24T14:29:44.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6qx0008rwtylslsoy5k","content":"<p>​        快速排序（Quicksort）是对冒泡排序的一种改进。</p>\n<p>​        快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>Go代码（从小到大）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交换两个数的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(i *<span class=\"keyword\">int</span>, j *<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    temp := *i</span><br><span class=\"line\">    *i = *j</span><br><span class=\"line\">    *j = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将片段分为大于v和小于v的两部分，并将两部分的分界索引值返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Partition</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    v := arr[l]</span><br><span class=\"line\"></span><br><span class=\"line\">    j := l</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := l + <span class=\"number\">1</span>; i &lt;= r; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] &lt; v &#123;</span><br><span class=\"line\">            swap(&amp;arr[j+<span class=\"number\">1</span>], &amp;arr[i])</span><br><span class=\"line\">            j++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(&amp;arr[l], &amp;arr[j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p := Partition(arr, l, r)</span><br><span class=\"line\">    Sort(arr, l, p)</span><br><span class=\"line\">    Sort(arr, p+<span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>​        快速排序（Quicksort）是对冒泡排序的一种改进。</p>\n<p>​        快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>","more":"<ul>\n<li><p>Go代码（从小到大）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交换两个数的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(i *<span class=\"keyword\">int</span>, j *<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    temp := *i</span><br><span class=\"line\">    *i = *j</span><br><span class=\"line\">    *j = temp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将片段分为大于v和小于v的两部分，并将两部分的分界索引值返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Partition</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    v := arr[l]</span><br><span class=\"line\"></span><br><span class=\"line\">    j := l</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := l + <span class=\"number\">1</span>; i &lt;= r; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] &lt; v &#123;</span><br><span class=\"line\">            swap(&amp;arr[j+<span class=\"number\">1</span>], &amp;arr[i])</span><br><span class=\"line\">            j++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(&amp;arr[l], &amp;arr[j])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> j</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, l <span class=\"keyword\">int</span>, r <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l &gt;= r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p := Partition(arr, l, r)</span><br><span class=\"line\">    Sort(arr, l, p)</span><br><span class=\"line\">    Sort(arr, p+<span class=\"number\">1</span>, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>"},{"title":"JDBC连接Mysql时出现的中文乱码问题","date":"2017-12-09T14:41:42.000Z","_content":"\n前段时间学习JDBC，要连接mysql获取数据。按照老师的样例数据，要存一些名字之类的信息，用的都是英文名，我当时就不太想用英文，就把我室友的名字存了进去，嘿嘿，结果，出问题了。\n\n<!--more-->\n\n![](JDBC连接Mysql时出现的中文乱码问题/code1.png)\n\n![](JDBC连接Mysql时出现的中文乱码问题/code2.png)\n\n连接数据库语句：\n\n`static final String DB_URL = \"jdbc:mysql://localhost/filemanagement\";`\n\n查询语句：\n\n`private static final String theUserQuery = \"SELECT name, password, role FROM userinfo WHERE name = ?\";`\n\n我是用我的名字做的查询，NullPointerException，很明显，没有用我的名字查到对应的数据，而数据库中是存在的。这是为什么呢？\n\n百度到的答案是中文乱码导致的查询不到东西，解决方案是，修改连接数据库语句为：\n\n`static final String DB_URL = \"jdbc:mysql://localhost/filemanagement?useUnicode=true&characterEncoding=GBK\";`\n\n重试！\n\n![](JDBC连接Mysql时出现的中文乱码问题/code3.png)\n\n可以了！但这是为什么呢？那两个参数是什么？为什么加上之后就解决问题了？\n\n这两个参数解释如下:\n\n![](JDBC连接Mysql时出现的中文乱码问题/description.png)\n\n两个参数的缺省值都是false。也就是说我们在连接mysql的时候指定了连接使用的字符集后，一切就正常了。但我还是不太了解其中的机制，所以继续查。\n\n原来Mysql连接进行查询等操作时存在一个字符集转换过程：\n\n1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；\n\n2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：\n\n• 使用每个数据字段的CHARACTER SET设定值；\n\n• 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；\n\n• 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；\n\n• 若上述值不存在，则使用character_set_server设定值。\n\n3.将操作结果从内部操作字符集转换为character_set_results。\n\n这些character set代表什么呢？\n\n**character_set_server**：默认的内部操作字符集\n\n**character_set_client**：客户端来源数据使用的字符集\n\n**character_set_connection**：连接层字符集\n\n**character_set_results**：查询结果字符集\n\n**character_set_database**：当前选中数据库的默认字符集\n\n**character_set_system**：系统元数据(字段名等)字符集\n\n还查到了一些常见问题，虽然和我的问题不太一样，但很有参考意义。\n\n• 向默认字符集为utf8的数据表插入utf8编码的数据前没有设置连接字符集，查询时设置连接字符集为utf8\n\n– 插入时根据MySQL服务器的默认设置，character_set_client、character_set_connection和character_set_results均为latin1；\n\n– 插入操作的数据将经过latin1=>latin1=>utf8的字符集转换过程，这一过程中每个插入的汉字都会从原始的3个字节变成6个字节保存；\n\n– 查询时的结果将经过utf8=>utf8的字符集转换过程，将保存的6个字节原封不动返回，产生乱码……\n\n• 向默认字符集为latin1的数据表插入utf8编码的数据前设置了连接字符集为utf8\n\n– 插入时根据连接字符集设置，character_set_client、character_set_connection和character_set_results均为utf8；\n\n– 插入数据将经过utf8=>utf8=>latin1的字符集转换，若原始数据中含有\\u0000~\\u00ff范围以外的Unicode字 符，会因为无法在latin1字符集中表示而被转换为“?”(0x3F)符号，以后查询时不管连接字符集设置如何都无法恢复其内容了。\n\n（此部分摘自鸟哥的blog，稍后附上链接）\n\n我数据库的表都是设置的utf8编码，但我第一次连接的时候没有设置连接字符集，所以默认为latin1，经过了从utf8=>latin1的转换，所以产生乱码。我第二次用的GBK编码，也没用utf8编码，为什么也可以了呢？其实是一个道理，中文不在latin1的编码中可是在GBK和utf8中，所以不会出问题。\n\n到此为止所有的疑问都解开了，大家是否懂了呢？\n\n\n\n附上参考博客链接：\n\n<http://www.laruence.com/2008/01/05/12.html>\n\nhttp://m.blog.csdn.net/zhliro/article/details/45464375","source":"_posts/JDBC连接Mysql时出现的中文乱码问题.md","raw":"---\ntitle: JDBC连接Mysql时出现的中文乱码问题\ndate: 2017-12-09 22:41:42\ncategories: JavaSE\ntags: [Java,JDBC]\n---\n\n前段时间学习JDBC，要连接mysql获取数据。按照老师的样例数据，要存一些名字之类的信息，用的都是英文名，我当时就不太想用英文，就把我室友的名字存了进去，嘿嘿，结果，出问题了。\n\n<!--more-->\n\n![](JDBC连接Mysql时出现的中文乱码问题/code1.png)\n\n![](JDBC连接Mysql时出现的中文乱码问题/code2.png)\n\n连接数据库语句：\n\n`static final String DB_URL = \"jdbc:mysql://localhost/filemanagement\";`\n\n查询语句：\n\n`private static final String theUserQuery = \"SELECT name, password, role FROM userinfo WHERE name = ?\";`\n\n我是用我的名字做的查询，NullPointerException，很明显，没有用我的名字查到对应的数据，而数据库中是存在的。这是为什么呢？\n\n百度到的答案是中文乱码导致的查询不到东西，解决方案是，修改连接数据库语句为：\n\n`static final String DB_URL = \"jdbc:mysql://localhost/filemanagement?useUnicode=true&characterEncoding=GBK\";`\n\n重试！\n\n![](JDBC连接Mysql时出现的中文乱码问题/code3.png)\n\n可以了！但这是为什么呢？那两个参数是什么？为什么加上之后就解决问题了？\n\n这两个参数解释如下:\n\n![](JDBC连接Mysql时出现的中文乱码问题/description.png)\n\n两个参数的缺省值都是false。也就是说我们在连接mysql的时候指定了连接使用的字符集后，一切就正常了。但我还是不太了解其中的机制，所以继续查。\n\n原来Mysql连接进行查询等操作时存在一个字符集转换过程：\n\n1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；\n\n2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：\n\n• 使用每个数据字段的CHARACTER SET设定值；\n\n• 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；\n\n• 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；\n\n• 若上述值不存在，则使用character_set_server设定值。\n\n3.将操作结果从内部操作字符集转换为character_set_results。\n\n这些character set代表什么呢？\n\n**character_set_server**：默认的内部操作字符集\n\n**character_set_client**：客户端来源数据使用的字符集\n\n**character_set_connection**：连接层字符集\n\n**character_set_results**：查询结果字符集\n\n**character_set_database**：当前选中数据库的默认字符集\n\n**character_set_system**：系统元数据(字段名等)字符集\n\n还查到了一些常见问题，虽然和我的问题不太一样，但很有参考意义。\n\n• 向默认字符集为utf8的数据表插入utf8编码的数据前没有设置连接字符集，查询时设置连接字符集为utf8\n\n– 插入时根据MySQL服务器的默认设置，character_set_client、character_set_connection和character_set_results均为latin1；\n\n– 插入操作的数据将经过latin1=>latin1=>utf8的字符集转换过程，这一过程中每个插入的汉字都会从原始的3个字节变成6个字节保存；\n\n– 查询时的结果将经过utf8=>utf8的字符集转换过程，将保存的6个字节原封不动返回，产生乱码……\n\n• 向默认字符集为latin1的数据表插入utf8编码的数据前设置了连接字符集为utf8\n\n– 插入时根据连接字符集设置，character_set_client、character_set_connection和character_set_results均为utf8；\n\n– 插入数据将经过utf8=>utf8=>latin1的字符集转换，若原始数据中含有\\u0000~\\u00ff范围以外的Unicode字 符，会因为无法在latin1字符集中表示而被转换为“?”(0x3F)符号，以后查询时不管连接字符集设置如何都无法恢复其内容了。\n\n（此部分摘自鸟哥的blog，稍后附上链接）\n\n我数据库的表都是设置的utf8编码，但我第一次连接的时候没有设置连接字符集，所以默认为latin1，经过了从utf8=>latin1的转换，所以产生乱码。我第二次用的GBK编码，也没用utf8编码，为什么也可以了呢？其实是一个道理，中文不在latin1的编码中可是在GBK和utf8中，所以不会出问题。\n\n到此为止所有的疑问都解开了，大家是否懂了呢？\n\n\n\n附上参考博客链接：\n\n<http://www.laruence.com/2008/01/05/12.html>\n\nhttp://m.blog.csdn.net/zhliro/article/details/45464375","slug":"JDBC连接Mysql时出现的中文乱码问题","published":1,"updated":"2017-12-09T15:35:25.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnjmw6r00009rwtyqxi64xzr","content":"<p>前段时间学习JDBC，要连接mysql获取数据。按照老师的样例数据，要存一些名字之类的信息，用的都是英文名，我当时就不太想用英文，就把我室友的名字存了进去，嘿嘿，结果，出问题了。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code1.png\" alt=\"\"></p>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code2.png\" alt=\"\"></p>\n<p>连接数据库语句：</p>\n<p><code>static final String DB_URL = &quot;jdbc:mysql://localhost/filemanagement&quot;;</code></p>\n<p>查询语句：</p>\n<p><code>private static final String theUserQuery = &quot;SELECT name, password, role FROM userinfo WHERE name = ?&quot;;</code></p>\n<p>我是用我的名字做的查询，NullPointerException，很明显，没有用我的名字查到对应的数据，而数据库中是存在的。这是为什么呢？</p>\n<p>百度到的答案是中文乱码导致的查询不到东西，解决方案是，修改连接数据库语句为：</p>\n<p><code>static final String DB_URL = &quot;jdbc:mysql://localhost/filemanagement?useUnicode=true&amp;characterEncoding=GBK&quot;;</code></p>\n<p>重试！</p>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code3.png\" alt=\"\"></p>\n<p>可以了！但这是为什么呢？那两个参数是什么？为什么加上之后就解决问题了？</p>\n<p>这两个参数解释如下:</p>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/description.png\" alt=\"\"></p>\n<p>两个参数的缺省值都是false。也就是说我们在连接mysql的时候指定了连接使用的字符集后，一切就正常了。但我还是不太了解其中的机制，所以继续查。</p>\n<p>原来Mysql连接进行查询等操作时存在一个字符集转换过程：</p>\n<p>1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</p>\n<p>2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：</p>\n<p>• 使用每个数据字段的CHARACTER SET设定值；</p>\n<p>• 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</p>\n<p>• 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</p>\n<p>• 若上述值不存在，则使用character_set_server设定值。</p>\n<p>3.将操作结果从内部操作字符集转换为character_set_results。</p>\n<p>这些character set代表什么呢？</p>\n<p><strong>character_set_server</strong>：默认的内部操作字符集</p>\n<p><strong>character_set_client</strong>：客户端来源数据使用的字符集</p>\n<p><strong>character_set_connection</strong>：连接层字符集</p>\n<p><strong>character_set_results</strong>：查询结果字符集</p>\n<p><strong>character_set_database</strong>：当前选中数据库的默认字符集</p>\n<p><strong>character_set_system</strong>：系统元数据(字段名等)字符集</p>\n<p>还查到了一些常见问题，虽然和我的问题不太一样，但很有参考意义。</p>\n<p>• 向默认字符集为utf8的数据表插入utf8编码的数据前没有设置连接字符集，查询时设置连接字符集为utf8</p>\n<p>– 插入时根据MySQL服务器的默认设置，character_set_client、character_set_connection和character_set_results均为latin1；</p>\n<p>– 插入操作的数据将经过latin1=&gt;latin1=&gt;utf8的字符集转换过程，这一过程中每个插入的汉字都会从原始的3个字节变成6个字节保存；</p>\n<p>– 查询时的结果将经过utf8=&gt;utf8的字符集转换过程，将保存的6个字节原封不动返回，产生乱码……</p>\n<p>• 向默认字符集为latin1的数据表插入utf8编码的数据前设置了连接字符集为utf8</p>\n<p>– 插入时根据连接字符集设置，character_set_client、character_set_connection和character_set_results均为utf8；</p>\n<p>– 插入数据将经过utf8=&gt;utf8=&gt;latin1的字符集转换，若原始数据中含有\\u0000~\\u00ff范围以外的Unicode字 符，会因为无法在latin1字符集中表示而被转换为“?”(0x3F)符号，以后查询时不管连接字符集设置如何都无法恢复其内容了。</p>\n<p>（此部分摘自鸟哥的blog，稍后附上链接）</p>\n<p>我数据库的表都是设置的utf8编码，但我第一次连接的时候没有设置连接字符集，所以默认为latin1，经过了从utf8=&gt;latin1的转换，所以产生乱码。我第二次用的GBK编码，也没用utf8编码，为什么也可以了呢？其实是一个道理，中文不在latin1的编码中可是在GBK和utf8中，所以不会出问题。</p>\n<p>到此为止所有的疑问都解开了，大家是否懂了呢？</p>\n<p>附上参考博客链接：</p>\n<p><a href=\"http://www.laruence.com/2008/01/05/12.html\" target=\"_blank\" rel=\"noopener\">http://www.laruence.com/2008/01/05/12.html</a></p>\n<p><a href=\"http://m.blog.csdn.net/zhliro/article/details/45464375\" target=\"_blank\" rel=\"noopener\">http://m.blog.csdn.net/zhliro/article/details/45464375</a></p>\n","site":{"data":{}},"excerpt":"<p>前段时间学习JDBC，要连接mysql获取数据。按照老师的样例数据，要存一些名字之类的信息，用的都是英文名，我当时就不太想用英文，就把我室友的名字存了进去，嘿嘿，结果，出问题了。</p>","more":"<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code1.png\" alt=\"\"></p>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code2.png\" alt=\"\"></p>\n<p>连接数据库语句：</p>\n<p><code>static final String DB_URL = &quot;jdbc:mysql://localhost/filemanagement&quot;;</code></p>\n<p>查询语句：</p>\n<p><code>private static final String theUserQuery = &quot;SELECT name, password, role FROM userinfo WHERE name = ?&quot;;</code></p>\n<p>我是用我的名字做的查询，NullPointerException，很明显，没有用我的名字查到对应的数据，而数据库中是存在的。这是为什么呢？</p>\n<p>百度到的答案是中文乱码导致的查询不到东西，解决方案是，修改连接数据库语句为：</p>\n<p><code>static final String DB_URL = &quot;jdbc:mysql://localhost/filemanagement?useUnicode=true&amp;characterEncoding=GBK&quot;;</code></p>\n<p>重试！</p>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/code3.png\" alt=\"\"></p>\n<p>可以了！但这是为什么呢？那两个参数是什么？为什么加上之后就解决问题了？</p>\n<p>这两个参数解释如下:</p>\n<p><img src=\"/2017/12/09/JDBC连接Mysql时出现的中文乱码问题/description.png\" alt=\"\"></p>\n<p>两个参数的缺省值都是false。也就是说我们在连接mysql的时候指定了连接使用的字符集后，一切就正常了。但我还是不太了解其中的机制，所以继续查。</p>\n<p>原来Mysql连接进行查询等操作时存在一个字符集转换过程：</p>\n<p>1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</p>\n<p>2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：</p>\n<p>• 使用每个数据字段的CHARACTER SET设定值；</p>\n<p>• 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；</p>\n<p>• 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；</p>\n<p>• 若上述值不存在，则使用character_set_server设定值。</p>\n<p>3.将操作结果从内部操作字符集转换为character_set_results。</p>\n<p>这些character set代表什么呢？</p>\n<p><strong>character_set_server</strong>：默认的内部操作字符集</p>\n<p><strong>character_set_client</strong>：客户端来源数据使用的字符集</p>\n<p><strong>character_set_connection</strong>：连接层字符集</p>\n<p><strong>character_set_results</strong>：查询结果字符集</p>\n<p><strong>character_set_database</strong>：当前选中数据库的默认字符集</p>\n<p><strong>character_set_system</strong>：系统元数据(字段名等)字符集</p>\n<p>还查到了一些常见问题，虽然和我的问题不太一样，但很有参考意义。</p>\n<p>• 向默认字符集为utf8的数据表插入utf8编码的数据前没有设置连接字符集，查询时设置连接字符集为utf8</p>\n<p>– 插入时根据MySQL服务器的默认设置，character_set_client、character_set_connection和character_set_results均为latin1；</p>\n<p>– 插入操作的数据将经过latin1=&gt;latin1=&gt;utf8的字符集转换过程，这一过程中每个插入的汉字都会从原始的3个字节变成6个字节保存；</p>\n<p>– 查询时的结果将经过utf8=&gt;utf8的字符集转换过程，将保存的6个字节原封不动返回，产生乱码……</p>\n<p>• 向默认字符集为latin1的数据表插入utf8编码的数据前设置了连接字符集为utf8</p>\n<p>– 插入时根据连接字符集设置，character_set_client、character_set_connection和character_set_results均为utf8；</p>\n<p>– 插入数据将经过utf8=&gt;utf8=&gt;latin1的字符集转换，若原始数据中含有\\u0000~\\u00ff范围以外的Unicode字 符，会因为无法在latin1字符集中表示而被转换为“?”(0x3F)符号，以后查询时不管连接字符集设置如何都无法恢复其内容了。</p>\n<p>（此部分摘自鸟哥的blog，稍后附上链接）</p>\n<p>我数据库的表都是设置的utf8编码，但我第一次连接的时候没有设置连接字符集，所以默认为latin1，经过了从utf8=&gt;latin1的转换，所以产生乱码。我第二次用的GBK编码，也没用utf8编码，为什么也可以了呢？其实是一个道理，中文不在latin1的编码中可是在GBK和utf8中，所以不会出问题。</p>\n<p>到此为止所有的疑问都解开了，大家是否懂了呢？</p>\n<p>附上参考博客链接：</p>\n<p><a href=\"http://www.laruence.com/2008/01/05/12.html\" target=\"_blank\" rel=\"noopener\">http://www.laruence.com/2008/01/05/12.html</a></p>\n<p><a href=\"http://m.blog.csdn.net/zhliro/article/details/45464375\" target=\"_blank\" rel=\"noopener\">http://m.blog.csdn.net/zhliro/article/details/45464375</a></p>"}],"PostAsset":[{"_id":"source/_posts/64位windows的Dos中取消了edit命令/canNotRun.png","post":"cjnjmw6qm0003rwtyf04rxonn","slug":"canNotRun.png","modified":1,"renderable":1},{"_id":"source/_posts/64位windows的Dos中取消了edit命令/edit-notFound.png","post":"cjnjmw6qm0003rwtyf04rxonn","slug":"edit-notFound.png","modified":1,"renderable":1},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/code1.png","post":"cjnjmw6r00009rwtyqxi64xzr","slug":"code1.png","modified":1,"renderable":1},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/code2.png","post":"cjnjmw6r00009rwtyqxi64xzr","slug":"code2.png","modified":1,"renderable":1},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/code3.png","post":"cjnjmw6r00009rwtyqxi64xzr","slug":"code3.png","modified":1,"renderable":1},{"_id":"source/_posts/JDBC连接Mysql时出现的中文乱码问题/description.png","post":"cjnjmw6r00009rwtyqxi64xzr","slug":"description.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjnjmw6qm0003rwtyf04rxonn","category_id":"cjnjmw6qq0005rwty7930g96t","_id":"cjnjmw6r6000drwtyof4s5mmd"},{"post_id":"cjnjmw6qo0004rwtygkesrvly","category_id":"cjnjmw6r2000arwtyl7i72k5v","_id":"cjnjmw6rb000hrwtyi6tezx3l"},{"post_id":"cjnjmw6qs0006rwtyfq2iw9np","category_id":"cjnjmw6r7000erwtyejj2eds7","_id":"cjnjmw6ri000mrwtytf262jws"},{"post_id":"cjnjmw6qx0008rwtylslsoy5k","category_id":"cjnjmw6r7000erwtyejj2eds7","_id":"cjnjmw6rm000qrwtyx0ejh62z"},{"post_id":"cjnjmw6r00009rwtyqxi64xzr","category_id":"cjnjmw6rh000lrwtyoxe6lelb","_id":"cjnjmw6rq000urwtyhxp8cgqw"}],"PostTag":[{"post_id":"cjnjmw6r00009rwtyqxi64xzr","tag_id":"cjnjmw6qk0002rwtyftgoy7a4","_id":"cjnjmw6r5000crwty5c47zvx1"},{"post_id":"cjnjmw6r00009rwtyqxi64xzr","tag_id":"cjnjmw6qw0007rwtyxgsb86xu","_id":"cjnjmw6r9000grwtylrascfry"},{"post_id":"cjnjmw6qa0000rwtybmerkcr8","tag_id":"cjnjmw6qk0002rwtyftgoy7a4","_id":"cjnjmw6rf000krwtyaafpizq8"},{"post_id":"cjnjmw6qa0000rwtybmerkcr8","tag_id":"cjnjmw6qw0007rwtyxgsb86xu","_id":"cjnjmw6rj000nrwtytqrl0gdt"},{"post_id":"cjnjmw6qa0000rwtybmerkcr8","tag_id":"cjnjmw6r3000brwty5byu29gp","_id":"cjnjmw6rl000prwtynyelctxk"},{"post_id":"cjnjmw6qa0000rwtybmerkcr8","tag_id":"cjnjmw6r8000frwty1z9flm95","_id":"cjnjmw6rn000rrwty1ivp1zdr"},{"post_id":"cjnjmw6qh0001rwty8nzksofd","tag_id":"cjnjmw6r3000brwty5byu29gp","_id":"cjnjmw6rp000trwty9jpv3z2q"},{"post_id":"cjnjmw6qm0003rwtyf04rxonn","tag_id":"cjnjmw6rj000orwtyw83tuf1t","_id":"cjnjmw6rt000wrwtydobaxwya"},{"post_id":"cjnjmw6qm0003rwtyf04rxonn","tag_id":"cjnjmw6ro000srwtyke45pamu","_id":"cjnjmw6ru000xrwtym7lgl3ff"},{"post_id":"cjnjmw6qo0004rwtygkesrvly","tag_id":"cjnjmw6rr000vrwtybhc8c58z","_id":"cjnjmw6rw000zrwtycdvcd0ye"},{"post_id":"cjnjmw6qs0006rwtyfq2iw9np","tag_id":"cjnjmw6ru000yrwtyj5s88q3p","_id":"cjnjmw6rz0012rwtymsp5t3j2"},{"post_id":"cjnjmw6qs0006rwtyfq2iw9np","tag_id":"cjnjmw6rx0010rwty3t2183uf","_id":"cjnjmw6s00013rwty3uuv6cso"},{"post_id":"cjnjmw6qx0008rwtylslsoy5k","tag_id":"cjnjmw6ru000yrwtyj5s88q3p","_id":"cjnjmw6s10015rwtyvnujsdk7"},{"post_id":"cjnjmw6qx0008rwtylslsoy5k","tag_id":"cjnjmw6rx0010rwty3t2183uf","_id":"cjnjmw6s20016rwtymq26b95z"}],"Tag":[{"name":"Java","_id":"cjnjmw6qk0002rwtyftgoy7a4"},{"name":"JDBC","_id":"cjnjmw6qw0007rwtyxgsb86xu"},{"name":"MySQL","_id":"cjnjmw6r3000brwty5byu29gp"},{"name":"JAR","_id":"cjnjmw6r8000frwty1z9flm95"},{"name":"Windows","_id":"cjnjmw6rj000orwtyw83tuf1t"},{"name":"Dos","_id":"cjnjmw6ro000srwtyke45pamu"},{"name":"PHP","_id":"cjnjmw6rr000vrwtybhc8c58z"},{"name":"算法","_id":"cjnjmw6ru000yrwtyj5s88q3p"},{"name":"排序","_id":"cjnjmw6rx0010rwty3t2183uf"}]}}